1>What is Node.js?
2>Is Node.js single-threaded or multi-threaded? how its handle asyncronous operation?
3> What is the event loop? 
        --->
        The event loop is a programming concept used to handle asynchronous operationsâ€”tasks that take time to completeâ€”without blocking the rest of a program. Itâ€™s most commonly associated with JavaScript, but the idea exists in many environments (browsers, Node.js, Pythonâ€™s asyncio, etc.).

        The core idea (in plain terms)

        The event loop lets a program:

        Start a long-running task (like fetching data or waiting for user input)

        Keep doing other work while that task runs
        Come back to the result later when itâ€™s ready All of this happens while usually running on a single main thread.

        How it works (step by step)

        In JavaScript (browser or Node.js), the runtime has several parts:

        1. Call Stack
        Keeps track of the functions currently being executed
        Runs code synchronously, one function at a time

        2. Web APIs / Background APIs
        Handle async tasks like:
        setTimeout
        HTTP requests
        DOM events
        These run outside the call stack

        3. Task Queues
        When async work finishes, callbacks are placed into queues:
        Macrotask queue (tasks)
        setTimeout, setInterval, DOM events
        Microtask queue
        Promise.then, queueMicrotask, MutationObserver

        4. Event Loop (the coordinator)
        The event loop continuously:
        Checks if the call stack is empty
        Runs all microtasks in the microtask queue
        Runs one macrotask
        Repeats forever
        Visual flow
        Call Stack (empty?)
        â†“
        Microtask Queue (run all)
        â†“
        Macrotask Queue (run one)
        â†“
        Repeat

        Why this matters

        It explains things like:

        console.log('A');
        setTimeout(() => console.log('B'), 0);
        Promise.resolve().then(() => console.log('C'));
        console.log('D');

        Output:
        A
        D
        C
        B

        Why?
        A and D run immediately
        Promise (C) goes to the microtask queue
        setTimeout (B) goes to the macrotask queue
        Microtasks always run before macrotasks
        Key benefits of the event loop
        Non-blocking I/O
        Efficient use of a single thread
        Responsive UIs and scalable servers

4>Difference between require() and import .
5>What is package.json?
6>What are modules in Node.js?
7>What is npm? Difference between dependencies and devDependencies
8>What is process.env?
9>What is middleware in Node.js?
10>What is __dirname and __filename?
11>Explain non-blocking I/O with example
12>How does the event loop work (phases)?
  ---->
    Step 1: Call Stack
    â”‚
    â”‚ Execute all synchronous code line by line
    â”‚
    Step 2: Web APIs / Background APIs
    â”‚
    â”‚ Async operations (timers, I/O, HTTP requests) are sent here
    â”‚ Execution happens outside the main thread
    â”‚
    Step 3: Queues
    â”‚
    â”‚ â†“ Microtask Queue (high priority)
    â”‚    - process.nextTick()
    â”‚    - Promise.then()
    â”‚    - queueMicrotask()
    â”‚
    â”‚ â†“ Macrotask Queue (phase-based)
    â”‚    - Timers (setTimeout, setInterval)
    â”‚    - I/O callbacks
    â”‚    - Check (setImmediate)
    â”‚    - Close callbacks
    â”‚
    Step 4: Event Loop
    â”‚
    â”‚ 1. Check if Call Stack is empty
    â”‚ 2. Run all Microtasks
    â”‚ 3. Run ONE Macrotask (from current phase)
    â”‚ 4. Repeat steps continuously
    â”‚
    Step 5: Back to Call Stack
    â”‚
    â”‚ Callbacks from queues are pushed onto the Call Stack
    â”‚ and executed line by line


    ----->
    Call Stack  â†’ run sync code
    Web APIs    â†’ execute async tasks
    Queues      â†’ wait for turn (microtasks first)
    Event Loop  â†’ coordinate queue â†’ call stack
    Call Stack  â†’ execute async callbacks

13>What is callback hell and how to avoid it?
    ---->
    Callback hell (also called the pyramid of doom) happens when you nest many callbacks inside each other to handle asynchronous operations, making code hard to read, maintain, and debug.
    What callback hell looks like ðŸ˜¬
    getUser(id, (err, user) => {
    if (err) return handleError(err);

    getOrders(user.id, (err, orders) => {
        if (err) return handleError(err);

        getPayments(orders[0].id, (err, payments) => {
        if (err) return handleError(err);

        processPayment(payments, (err, result) => {
            if (err) return handleError(err);
            console.log(result);
        });
        });
    });
    });

14>What are streams? Types of streams 
    ----->
    Streams are a way to read or write data piece by piece (in chunks) instead of loading the entire data into memory at once. Theyâ€™re especially useful for large files, network data, and real-time processing.
    Why streams exist

    Without streams âŒ:

    const data = fs.readFileSync('large-video.mp4'); // loads entire file

    With streams âœ…:

    fs.createReadStream('large-video.mp4')
    .pipe(res);

    Benefits:
    Lower memory usage
    Faster processing
    Handles large data efficiently

15> Difference between spawn and fork.
    ---->
    In Node.js, spawn and fork are both used to create child processes, but they serve different purposes and have different capabilities.

    High-level difference
    | Feature               | `spawn()`                    | `fork()`                       |
| Purpose               | Run any system command       | Run another Node.js script     |
| IPC (message passing) | âŒ Not built-in               | âœ… Built-in                     |
| Data type             | Streams (`stdout`, `stderr`) | Messages (`process.send`)      |
| Use case              | Shell commands, binaries     | Worker processes, CPU-heavy JS |
| Module                | `child_process`              | `child_process`                |



16>What is clustering in Node.js?
17>how clustor is different from worker threads in nodejs ?
    ---->
    Cluster = multiple Node.js processes
    Worker Threads = multiple threads inside one Node.js process

18> How does Node handle concurrency?
19>What is buffer?
    ---->
    A Buffer is a data structure used to handle raw binary data directly in memory. In Node.js, the Buffer class lets you work with bytesâ€”things like files, network packets, images, or streamsâ€”where data isnâ€™t just plain text or JavaScript objects.
    Buffer.from('Hello', 'utf8');
20> What is setImmediate() vs setTimeout()?
    ----> 
    both are macrotask 
    setImmediate() have the more precidence over setTimeout() in the macro
21> What happens when you block the event loop?

